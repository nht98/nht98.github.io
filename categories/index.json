[{"content":"Vấn đề Mình đã gặp trường hợp là rõ ràng đã thêm một vài file vào .gitignore rồi nhưng thi thoảng vẫn thấy sự thay đổi của nó hiện lên git status. Vậy nguyên nhân là gì? Có phải git bị lỗi không?\nVí dụ trong project hiện tại mình đang code, bây giờ mình không muốn up file main.dart lên mỗi khi thay đổi nó nữa. Như ở đây là file main.dart đang có sự thay đổi và nó được liệt kê ở mục Unstaged Changes.\nBây giờ mình sẽ ignore file này giống như hình bên dưới, tool nó sẽ tự động thêm đúng đường dẫn tới file đó vào trong file .gitignore giúp mình :D.\nNhư cái hình bên dưới là nó đã thêm ok rồi đó.\nNhưng mà để ý cái phần Unstaged Changes kìa, file main.dart vẫn còn đó lẽ ra nó phải biến mất khỏi phần đó chứ nhỉ.\nNguyên nhân Lý do trong trường hợp này đó là cái file main.dart của mình đã từng được commit từ trước đó rồi, và git nó đã lưu trong cache rồi và đó là những file cần lắng nghe sự thay đổi, nó sẽ không quan tâm là ở trong .gitignore có liệt kê file đó ra hay là không.\nOk biết nguyên nhân rồi thì giờ làm gì để khắc phục ?\nGiải pháp Đây là câu lệnh sẽ giúp mình xoá đi cache của file mà mình muốn (nó là lệnh của git nên hệ điều hành nào cũng như vậy nha, có thể trên Windows thì các trỏ đường dẫn của nó khác chút thôi).\n Đối với file  git rm --cached \u0026lt;path to file\u0026gt; Ví dụ xoá file main.dart\ngit rm --cached lib/main.dart  Đối với thư mục  git rm --cached -r \u0026lt;path to folder\u0026gt; Ví dụ xoá thư mục lib\ngit rm --cached -r lib Sau khi xoá cache xong thì nó sẽ hiện như thế này.\nTrong Staged Changes nó sẽ hiện thế này.\nLệnh này chỉ xoá cache của git thôi chứ file của mình thì vẫn còn nguyên :D không ảnh hưởng gì cả, hình dưới là sau khi mình remove cache file vẫn còn nguyên.\nXong rồi, bây giờ nếu muốn thêm file trở lại để push lên git thì chỉ cần xoá phần liệt kê file đó trong .gitignore là được, nó sẽ hiện như hình dưới.\nVậy là ok rồi, stage mấy cái đó vào push lên là được.\nBạn có thể để lại ý kiến bằng cách comment nha :v\n","description":"Mình đã gặp trường hợp là rõ ràng đã thêm một vài file vào .gitignore rồi nhưng thi thoảng vẫn thấy sự thay đổi của nó hiện lên git status. Vậy nguyên nhân là gì? Có phải git bị lỗi không?","id":0,"section":"posts","tags":["git"],"title":"Hình như Git ignore không hoạt động ?","uri":"https://tbm98.github.io/posts/gitignore-khong-hoat-dong/"},{"content":"Vấn đề ? Mình có 1 page là profile và login, ở profile mình sử dụng ChangeNotifierProvider để cung cấp một lớp ChangeNotifier (tạm gọi là lớp state) có nhiệm vụ lưu giữ thông tin user hiện tại. Trong trường hợp chưa đăng nhập thì sẽ hiển thị nút đăng nhập yêu cầu chuyển sang page login để người dùng đăng nhập. Sau khi đăng nhập xong sẽ pop quay trở lại page profile. Bây giờ ở màn hình login mình muốn sử dụng được lớp ChangeNotifier của màn hình profile thì phải làm thế nào ?\nMột vài cách có thể sử dụng  Khi màn hình login pop sẽ truyền thêm thông tin user trở lại cho màn hình profile, cách này sẽ không hợp lí nếu như dữ liệu update nhiều hơn 1 hoặc ở màn hình login muốn gọi hàm từ lớp state. Đặt ChangeNotifierProvider ở bên trên materialApp/cupertinoApp: cách này được khá nhiều người sử dụng, thường thì những lớp nào họ muốn dùng chung cho toàn bộ ứng dụng sẽ đặt hết vào 1 MultiProvider và đặt nó ở ngoài cùng (bọc materialApp / cupertinoApp). Nhưng trong trường hợp mình có nhiều page khác nữa mà lại đặt lớp state nằm ở ngoài cùng sẽ dẫn tới tốn bộ nhớ khi không sử dụng tới. Còn một vài cách khác nữa ví dụ như truyền callback hay jj đó nhưng mình sẽ bỏ qua và chỉ sử dụng những gì sẵn có của provider thôi.  Hướng giải quyết của mình. Cách của mình là sử dụng ChangeNotifierProvider.value để bọc page mà mình muốn push sang.\nSở dĩ phải bọc thêm 1 ChangeNotifierProvider là vì materialApp/cupertinoApp bản thân nó sử hữu 1 cái Navigator, khi mình push sang màn hình mới lập tức màn hình này sẽ là first child (con đầu tiên) của materialApp/cupertinoApp trong widget tree. Vì nó là con đầu tiên nên 1 là phải đặt ChangeNotifierProvider ở bên trên cả materialApp/cupertinoApp hoặc là phải bọc nó bởi 1 ChangeNotifierProvider mới. Còn 1 cách khác là tạo thêm 1 Navigator khác để tự quản lý cái navigation riêng nhưng rắc rối hơn nên bỏ qua :)) .\nLớp này sẽ cung cấp một ChangeNotifierProvider với một ChangeNotifier sẵn có từ trước, và mình sẽ sử dụng lớp state có sẵn bằng câu lệnh này\n1  Provider.of\u0026lt;ClassName\u0026gt;(context, listen: false)   Khi từ màn hình profile muốn push sang màn hình login thì sẽ như thế này\n1 2 3 4 5 6  Navigator.of(context).push( MaterialPageRoute( builder: (_) =\u0026gt; ChangeNotifierProvider.value(value: Provider.of\u0026lt;ClassName\u0026gt;(context, listen: false), child: LoginPage()) ) );   Demo Đầu tiên tạo Profile page với nội dung như sau\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class ProfilePage extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( appBar: AppBar( title: Text(\u0026#39;Profile page\u0026#39;), ), body: Center( child: Column( mainAxisSize: MainAxisSize.min, children: \u0026lt;Widget\u0026gt;[ // ở đây mình dùng selector để lắng nghe sự thay đổi của biến user  Selector\u0026lt;ClassName, String\u0026gt;( selector: (_, m) =\u0026gt; m.user, builder: (_, data, __) { return Text(\u0026#39;current user is $data\u0026#39;); }, ), // ở nút login mình sẽ bọc LoginPage bằng một ChangeNotifierProvider.value  // với value là ClassName được cung cấp bới ChangeNotifierProvider  // ở bên trên của Profile page  RaisedButton( onPressed: () { Navigator.of(context).push(MaterialPageRoute( builder: (_) =\u0026gt; ChangeNotifierProvider.value( value: Provider.of\u0026lt;ClassName\u0026gt;(context, listen: false), child: LoginPage()))); }, child: Text(\u0026#39;login\u0026#39;)), ], ), ), ); } }   Sau đó ở Login page sẽ code như sau\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class LoginPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#39;Login page\u0026#39;), ), body: Container( child: Center( child: RaisedButton( onPressed: () { // ở đây mình vẫn truy cập được tới ClassName bình thường  // vì mình đã bọc LoginPage bằng một ChangeNotifierProvider.value  // lúc gọi Navigator.push rồi  Provider.of\u0026lt;ClassName\u0026gt;(context, listen: false) .loginSuccess(\u0026#39;TBM98\u0026#39;); }, // ở đây mình dùng selector để lắng nghe sự thay đổi của biến user  child: Selector\u0026lt;ClassName, String\u0026gt;( selector: (_, m) =\u0026gt; m.user, builder: (_, data, __) { return Text(\u0026#39;current user is $data, login demo\u0026#39;); }, ), ), ), )); } }   Full source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:provider/provider.dart\u0026#39;; void main() { runApp(new MyApp()); } class ClassName with ChangeNotifier { String user = \u0026#39;\u0026#39;; void loginSuccess(String value) { user = value; notifyListeners(); } } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: new ThemeData( primarySwatch: Colors.blue, ), home: ChangeNotifierProvider( create: (_) =\u0026gt; ClassName(), child: ProfilePage()), ); } } class ProfilePage extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( appBar: AppBar( title: Text(\u0026#39;Profile page\u0026#39;), ), body: Center( child: Column( mainAxisSize: MainAxisSize.min, children: \u0026lt;Widget\u0026gt;[ Selector\u0026lt;ClassName, String\u0026gt;( selector: (_, m) =\u0026gt; m.user, builder: (_, data, __) { return Text(\u0026#39;current user is $data\u0026#39;); }, ), RaisedButton( onPressed: () { Navigator.of(context).push(MaterialPageRoute( builder: (_) =\u0026gt; ChangeNotifierProvider.value( value: Provider.of\u0026lt;ClassName\u0026gt;(context, listen: false), child: LoginPage()))); }, child: Text(\u0026#39;login\u0026#39;)), ], ), ), ); } } class LoginPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#39;Login page\u0026#39;), ), body: Container( child: Center( child: RaisedButton( onPressed: () { Provider.of\u0026lt;ClassName\u0026gt;(context, listen: false) .loginSuccess(\u0026#39;TBM98\u0026#39;); }, child: Selector\u0026lt;ClassName, String\u0026gt;( selector: (_, m) =\u0026gt; m.user, builder: (_, data, __) { return Text(\u0026#39;current user is $data, login demo\u0026#39;); }, ), ), ), )); } }   Lần đầu tiên mình viết bài :D Nếu có gì thắc mắc bạn có thể comment mình sẽ trả lời.\n","description":"Sử dụng chung ChangeNotifier cho nhiều page trong Flutter","id":1,"section":"posts","tags":["flutter"],"title":"Sử dụng chung ChangeNotifier cho nhiều page trong Flutter","uri":"https://tbm98.github.io/posts/su-dung-chung-changenotifier-cho-nhieu-page-flutter/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  ","description":"Hugo, the world’s fastest framework for building websites","id":2,"section":"","tags":null,"title":"About","uri":"https://tbm98.github.io/about/"}]